r"""
LKH Algorithm for HCP
"""

# Copyright (c) 2024 Thinklab@SJTU
# ML4CO-Kit is licensed under Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
# http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
# EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
# MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
# See the Mulan PSL v2 for more details.


import os
import pathlib
import tempfile
import subprocess
import numpy as np
from ml4co_kit.extension import tsplib95
from ml4co_kit.task.routing.hcp import HCPTask


def hcp_lkh(
    task_data: HCPTask,
    lkh_scale: int = 1e6,
    lkh_max_trials: int = 500,
    lkh_path: pathlib.Path = "LKH",
    lkh_runs: int = 1,
    lkh_seed: int = 1234,
    lkh_special: bool = False,
):
    """
    Solve Hamiltonian Cycle Problem using LKH solver.
    
    HCP is converted to a special TSP where:
    - Adjacent nodes have distance 1
    - Non-adjacent nodes have a large penalty distance
    """
    
    # Preparation 
    adj_matrix = task_data.adj_matrix.astype(int)
    nodes_num = task_data.nodes_num
    
    # Convert HCP to TSP: create distance matrix
    # For adjacent nodes: distance = 1, for non-adjacent: large penalty
    large_penalty = nodes_num * 100  # Large enough to avoid non-existent edges
    
    # Create TSP distance matrix from adjacency matrix
    dist_matrix = np.where(
        adj_matrix > 0, 
        1,  # Adjacent nodes have distance 1
        large_penalty  # Non-adjacent nodes have large penalty
    )
    
    # Scale the distances
    scaled_dists = (dist_matrix * lkh_scale).astype(np.int32)
    
    # Create temporary files
    hcp_file = tempfile.NamedTemporaryFile(mode="w", delete=False, suffix='.hcp')
    par_file = tempfile.NamedTemporaryFile(mode="w", delete=False, suffix='.par')
    tour_file = tempfile.NamedTemporaryFile(mode="w", delete=False, suffix='.tour')
    
    # Write HCP Data to TSPLIB-compatible File
    # We use TSP format with explicit edge weights to represent the graph
    with open(hcp_file.name, "w") as f:
        f.write(f"NAME : {hcp_file.name}\n")
        f.write(f"COMMENT : HCP problem converted to TSP, generated by ML4CO-Kit\n")
        f.write("TYPE : TSP\n")  # Use TSP type for compatibility
        f.write(f"DIMENSION : {nodes_num}\n")
        f.write("EDGE_WEIGHT_TYPE : EXPLICIT\n")
        f.write("EDGE_WEIGHT_FORMAT : FULL_MATRIX\n")
        f.write("EDGE_WEIGHT_SECTION\n")
        for i in range(nodes_num):
            line = ' '.join([str(elem) for elem in scaled_dists[i]])
            f.write(f"{line}\n")
        f.write("EOF\n")
    
    # Write Parameters for LKH
    params = dict()
    params["PROBLEM_FILE"] = hcp_file.name
    params["MAX_TRIALS"] = lkh_max_trials
    params["RUNS"] = lkh_runs
    params["SEED"] = lkh_seed
    params["TOUR_FILE"] = tour_file.name
    
    # Add SPECIAL flag if requested
    if lkh_special:
        par_file.write("SPECIAL\n")
    
    # Write all parameters to par file
    for k, v in params.items():
        par_file.write(f"{k} = {v}\n")
    par_file.close()    
    
    try:
        # Execute LKH solver
        # stdin=DEVNULL for preventing a "Press any key" pause at the end of execution
        subprocess.check_output(
            [lkh_path, par_file.name], 
            stderr=subprocess.STDOUT, 
            stdin=subprocess.DEVNULL
        )
    except subprocess.CalledProcessError as e:
        raise Exception(f"LKH solver failed: {e.output.decode()}")
    
    # Read and process the tour result
    try:
        # Load tour using tsplib95
        tour_data = tsplib95.load(tour_file.name)
        tour = tour_data.tours[0]  # Get the first tour
        
        # Convert to numpy array and adjust indices (LKH uses 1-based indexing)
        np_tour = np.array(tour) - 1
        
        # Ensure the tour is a cycle by adding the start node at the end if needed
        if len(np_tour) > 0 and np_tour[0] != np_tour[-1]:
            np_tour = np.append(np_tour, np_tour[0])
        
        # Convert to list for storage
        sol = np_tour.tolist()
        
    except Exception as e:
        raise Exception(f"Failed to parse tour file: {str(e)}")
    
    # Store the tour in the task_data using from_data method
    # We need to ensure the solution is stored properly
    task_data.from_data(
        adj_matrix=adj_matrix,  # Pass the original adjacency matrix
        points=task_data.points,  # Pass points if available
        sol=np.array(sol),  # Store as numpy array
        ref=False
    )
    
    # Clean up temporary files
    os.remove(par_file.name)
    if os.path.exists(hcp_file.name):
        os.remove(hcp_file.name)
    if os.path.exists(tour_file.name):
        os.remove(tour_file.name)
    